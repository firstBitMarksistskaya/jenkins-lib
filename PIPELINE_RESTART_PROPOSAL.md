# Варианты решения для поддержки рестарта пайплайна

## Проблема
Текущая архитектура с чтением конфигурации сборки на шаге `pre-stage` блокирует возможность перезапуска пайплайна с конкретного стейджа. При рестарте возникает ошибка:

```
java.lang.NullPointerException: Cannot get property 'stageFlags' on null object
```

Это происходит потому, что конфигурация загружается только в `pre-stage` и сохраняется в `@Field` переменных, которые не сохраняются при рестарте пайплайна.

## Анализ существующей архитектуры

### Текущий подход
- Конфигурация загружается в `pre-stage` через `jobConfiguration()`
- Сохраняется в глобальных `@Field` переменных (`config`, `agent1C`, `agentEdt`)
- Все последующие стейджи используют эти переменные в `when` выражениях
- При рестарте `pre-stage` не выполняется повторно → переменные остаются `null`

### Использование stash в библиотеке
Библиотека активно использует stash для передачи артефактов между стейджами:
- `GetExtensions.EXTENSIONS_STASH` для расширений
- `Bdd.ALLURE_STASH` для результатов BDD
- `Yaxunit.YAXUNIT_ALLURE_STASH` для результатов тестов
- `'1Cv8.1CD.zip'` для базы данных

## Предлагаемые варианты решения

### Вариант 1: Стэшинг конфигурации (Рекомендуемый)

**Описание**: Сохранение конфигурации через механизм stash/unstash

**Схема реализации**:
```
pre-stage:
├── Загрузка конфигурации (jobConfiguration())
├── Сериализация в JSON (writeJSON)
└── Сохранение в stash ('pipeline-config')

Каждый стейдж с when условием:
├── Проверка наличия config в памяти
├── Если null → unstash 'pipeline-config'
├── Десериализация JSON → config
└── Использование config в when выражении
```

**Преимущества**:
- ✅ Минимальные изменения в коде
- ✅ Совместимость с существующими конфигурациями
- ✅ Использует проверенный механизм stash
- ✅ Автоматическая очистка после выполнения пайплайна

**Недостатки**:
- ⚠️ Небольшой overhead на unstash в каждом стейдже
- ⚠️ Зависимость от механизма stash Jenkins

**Изменения**:
- Модификация `pre-stage` для стэшинга конфигурации
- Создание функции `safeLoadConfig()` с логикой fallback
- Замена прямых обращений к `config` в `when` выражениях

### Вариант 2: Ленивая загрузка конфигурации

**Описание**: Загрузка конфигурации по требованию в каждом стейдже

**Схема реализации**:
```
Каждый стейдж:
├── Проверка наличия config в памяти
├── Если null → jobConfiguration()
├── Кэширование в @Field переменной
└── Использование config
```

**Преимущества**:
- ✅ Полная автономность каждого стейджа
- ✅ Не зависит от stash механизма
- ✅ Простая логика

**Недостатки**:
- ❌ Повторная загрузка конфигурации в каждом стейдже
- ❌ Потенциальные проблемы с консистентностью конфигурации
- ❌ Больше обращений к файловой системе

### Вариант 3: Параметры пайплайна

**Описание**: Передача ключевых настроек через параметры Jenkins

**Схема реализации**:
```
pre-stage:
├── Загрузка конфигурации
├── Извлечение ключевых параметров (stageFlags, агенты)
└── Установка как параметры билда (env/params)

Стейджи:
└── Использование env.STAGE_FLAGS_* в when условиях
```

**Преимущества**:
- ✅ Нативный подход Jenkins
- ✅ Параметры видны в UI Jenkins
- ✅ Естественное сохранение при рестарте

**Недостатки**:
- ❌ Кардинальное изменение архитектуры
- ❌ Ограниченность типов данных для параметров
- ❌ Сложная сериализация сложных объектов

### Вариант 4: Гибридный подход

**Описание**: Комбинация стэшинга с fallback на свежую загрузку

**Схема реализации**:
```
safeLoadConfig():
├── 1. Проверка config в памяти → return config
├── 2. Попытка unstash 'pipeline-config' → deserialize → cache → return
└── 3. Fallback: jobConfiguration() → cache → return
```

**Преимущества**:
- ✅ Максимальная надёжность (3 уровня fallback)
- ✅ Работает в любых сценариях
- ✅ Минимальный performance impact

**Недостатки**:
- ⚠️ Более сложная логика
- ⚠️ Потенциальные различия в конфигурации при fallback

## Рекомендация

**Рекомендую Вариант 4 (Гибридный подход)** как наиболее надёжное решение:

1. **Этап 1**: Модификация `pre-stage` для стэшинга конфигурации
2. **Этап 2**: Создание функции `safeLoadConfig()` с тройным fallback
3. **Этап 3**: Замена всех `config.stageFlags.*` на `safeLoadConfig().stageFlags.*` в when условиях
4. **Этап 4**: Тестирование сценариев рестарта

Это решение обеспечивает максимальную совместимость при минимальных изменениях и гарантирует работу даже в edge cases.

## Детальный план реализации

### Фаза 1: Подготовка (1-2 часа)
- [ ] Анализ всех мест использования `config` в when условиях
- [ ] Создание тестовых сценариев для проверки рестарта
- [ ] Подготовка rollback плана

### Фаза 2: Реализация (2-3 часа)
- [ ] Добавление стэшинга в pre-stage
- [ ] Создание функции safeLoadConfig()
- [ ] Обновление всех when условий
- [ ] Обновление агентских переменных

### Фаза 3: Тестирование (1-2 часа)
- [ ] Unit тесты для safeLoadConfig()
- [ ] Integration тесты для сценариев рестарта
- [ ] Проверка обратной совместимости

Ожидаемое время реализации: 4-7 часов
Риски: Минимальные, изменения обратимы

Жду вашего одобрения для начала реализации выбранного варианта.